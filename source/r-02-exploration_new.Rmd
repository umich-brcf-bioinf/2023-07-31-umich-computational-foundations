---
title: "Data Exploration"
output:
        html_document:
            includes:
                in_header: header.html
            theme: paper
            toc: true
            number_sections: false
            fig_caption: false
            markdown: GFM
            code_download: false
---

<style type="text/css">

body, td {
   font-size: 14px;
}
code.r{
  font-size: 12px;
}
pre {
  font-size: 12px
}

</style>

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-")
```

# Objectives

- Subset, filter, mutate, group and summarize data with `dplyr` functions. Highlight base R equivalents.
- Understand how to string together multiple functions with the `%>%` pipe.
- Create plots with both discrete and continuous variables with `ggplot2`.
- Understand mappings, geometries, and layering in `ggplot2`.
- Modify the color, theme, and axis labels of a plot.

# Loading data

In the previous lesson we used the `read_csv()` function to load the `gapminder_1997` data. Let's do that again:

```{r, 'load_gapminder_1997_display', eval = FALSE}
gapminder_1997 = read_csv('data/gapminder_1997.csv')
```

```{r, 'load_gapminder_1997', echo = FALSE}
gapminder_1997 = read_csv('../data/gapminder_1997.csv')
```

This time, let's look more closely at the data. If we type the name of the object and evaluate it, we'll see a preview:

```{r, 'preview_data'}
gapminder_1997
```

**Checkpoint**

The output shows we have "a tibble" and its dimensions are 142 rows by 6 columns. We then see:

- Column headings (country, year, etc)
- Column data types (chr, dbl, etc)
- The entries of the first 10 rows.

Data in the form of a table is very common in R. The "base R" type is called a `data.frame`. The `tidyverse` extends on this notion with a `tibble`. The commands we'll learn in this lesson work on `data.frame`s and `tibble`s. We'll use `data.frame`, `tibble`, and "data table" interchangeably throughout the lessons.

# Exploring data tables

After reading in data, it's a good habit to preview it, look at summaries of it, and, in so doing, look for issues. When data contains hundreds of rows, it's a good idea to get a sense for the values and ranges of the data.

## Get stats with `summary()`

The `summary()` function, from base R, takes a data table as input and will summarize the columns automatically depending on their data type.

```{r, 'summary'}
summary(gapminder_1997)
```

We see that for the numeric data we get quantile information and the mean, whereas for character data we simply get the length of the column. For data with NAs, the number thereof would be displayed.

## Get stats with `summarize()`

If we wanted to know the mean life expectancy in the dataset, we could use the the `dplyr` `summarize()` function, specifying that we want the `mean()`:

```{r, 'summarize_lifeexp'}
summarize(gapminder_1997, avgLifeExp = mean(lifeExp))
```

We can use any column name as the input to `mean()`, so long as it's a numeric, and we get a new tibble with our value returned as a column, named as specified. Note, this matches the result of `summary()` with some difference in the number of significant digits displayed. Alternatively, we could have simply applied `mean()` directly to the column `lifeExp`:

```{r, 'mean_lifexp_dollar'}
mean(gapminder_1997$lifeExp)
```

This is the base R way, with the `$` being how columns of a data table are accessed. The `mean()` function returns a number, whereas `summarize()` returns a `tibble`. In the `tidyverse`, a function whose input is a `tibble` will also have a `tibble` as output. 

**Checkpoint**

> ## Tip: Reference columns by name
> 
> While it is possible to access columns by their numerical index, this is less prefereable than using the explicit name of the column because altering the table could change the column indices. Depending on the situation, we might not even get an error, and instead would be simply operating on the wrong column. A dangerous situation to be in.

## Find unique values with `distinct()`

Data is often subject to errors. To quickly catch data entry problems, the `distinct()` function can be used to show all unique values in the column of a table. Let's take a look at the distinct values of the continents column:

```{r, 'distinct_continent'}
distinct(gapminder_1997, continent)
```

Here we get a `tibble` back with the unique continent names in their order of appearance. There is an equivalent base R way to do this with the `unique()` function:

```{r, 'unique_continent'}
unique(gapminder_1997$continent)
```

Either way, if there was a misspelled entry, for example, "Urope" we would have immediately seen it.

**Checkpoint**

## Sorting data with `arrange()`

We have a rich dataset whose default ordering is by country. But it's natural to ask questions like "What country has the highest life expectancy?" or "What country had the highest GDP per capita?" The `arrange()` function can help us quickly find the answers.

```{r, 'arrange_lifeexp'}
arrange(gapminder_1997, lifeExp)
```

This seems to have done an ascending order on `lifeExp` by default. We have some options, one of which is to wrap the column of interest in the `desc()` function to indicate we want the order to be descending.

```{r, 'arrange_lifeexp_desc'}
arrange(gapminder_1997, desc(lifeExp))
```

And here we see that Japan is the country with the longest lived citizens at a little over 80 years.

If we wanted to use base R, we might start with the `sort()` function:

```{r, 'sort_lifeexp'}
sort(gapminder_1997$lifeExp, decreasing = TRUE)
```

But this only sorts the `lifeExp` column and drops all the other information in the table, so we know the highest life expectancy but not the country to which it belongs. There is another function called `order()` which returns the indices of the sorting. Let's call it first by itself and think about how to get what we want from it:

```{r, 'order_lifexp'}
order(gapminder_1997$lifeExp, decreasing = TRUE)
```

This is a vector of the row indices of `gapminder_1997` and the meaning of the result is that the 67th row is the entry with the highest `lifeExp`, the 56th row the second highest etc. We can re-order the rows of `gapminder_1997` using this vector of indices as in:

```{r, 'order_lifexp2'}
gapminder_1997[order(gapminder_1997$lifeExp, decreasing = TRUE), ]
```

We see that we got the same thing as in `arrange()`. We observe that a data table has two dimensions (rows and columns). With square-bracket accessors, the rows are first and the columns are second, separated by a comma. We left the second entry in the `[,]` blank to indicate we want all columns returned. In the first entry, denoting the rows, we give it the vector of indices with the correct ordering.

This is an excellent example of the relative simplicity of the `tidyverse` over base R.

**Checkpoint**

## Subset columns with `select()`

Sometimes data tables have many columns, and it can be useful to select only a few of them to export, use downstream, preview, etc. The `select()` function works on columns:

```{r, 'select_positive'}
select(gapminder_1997, country, year, lifeExp)
```

We can do the equivalent of `select()` statement using base R with:

```{r, 'base_select_positive'}
gapminder_1997[ , c('country', 'year', 'lifeExp')]
```

Here we use the square-bracket notation again, leaving the row position blank returns all rows, and in the column position we specify the names of the columns as a vector with the `c()` function, meaning "combine", creates a temporary vector of column names. Note that we quoted the column names in this code, whereas in `select()` we didn't have to.

**Checkpoint**

Columns can be removed using `select()` with a "minus" in front of the column name.

```{r, 'select_negative'}
select(gapminder_1997, -year)
```

Notice the `year` column is no longer displayed. The equivalent can be done in base R with:

```{r, 'base_select_negative'}
gapminder_1997[, -2]
```

Note, the base R syntax works for numerical column indices only. The following throws a somewhat inscrutable error if we try to use the name of the column as we did in the `tidyverse` syntax:

```{r, 'base_select_negative_error', error = TRUE}
gapminder_1997[, -c('year')]
```

## Saving objects

If we view `gapminder_1997` we notice haven't changed the original data because we haven't saved the object.

```{r, 'df_persists'}
gapminder_1997
```

To manipulate `gapminder_1997` and save it as a new object we have to assign it a new object name:

```{r, 'new_df'}
gapminder_column_subset = select(gapminder_1997, country, year, lifeExp)
gapminder_column_subset
```

## Saving objects to file

The original data file we read in `data/gapminder_1997.csv` remains the same throughout all these manipulations. What happens in R stays in R until we explicitly write a new object to the same file. **It's good practice to keep raw input data separate, and to never overwrite it.** Let's use the `write_csv()` function to write the `gapminder_column_subset` data to a file. First let's look at `?write_csv` and determine what are the required parameters.

It looks like `x`, the data to be written and `file`, the path to the output file are required. There are other options, but we won't use them here.

```{r, 'write_csv', eval = FALSE}
write_csv(gapminder_column_subset, file = 'gapminder_subset.csv')
```

**Checkpoint**

## Narrow down rows with `filter()`

We have seen that `select()` subsets the columns of a table. The function `filter()` subsets the rows of a data table based on logical criteria. So first, a note about logical operators in R:

| Operator | Description              | Example      |
|----------|--------------------------|--------------|
| <        | less than                | `pop < 575990` |
| <=       | less than or equal to    | `pop <= 575990` |
| >        | greater than             | `pop > 1000000` |
| >=       | greater than or equal to | `pop >= 38000000` |
| ==       | exactly equal to         | `continent == 'Africa'` |
| !=       | not equal to             | `continent != 'Asia'` |
| !x       | not x                    | `!(continent == 'Africa')` |
| a \| b   | a or b                   | `pop < 575990 | pop > 1000000` |
| a & b    | a and b                  | `continent == 'Asia' & continent == 'Africa'` |
| a %in% b | a in b                   | `continent %in% c('Asia', 'Africa')` |

With these operators in mind we can filter the `gapminder_1997` data table in a variety of ways. To filter for only the African data we could:

```{r, 'filter_by_continent'}
filter(gapminder_1997, continent == 'Africa')
```

The base R equivalent of the above uses the square bracket notation that we saw earlier with a twist:

```{r, 'base_filter_by_continent'}
gapminder_1997[gapminder_1997$continent == 'Africa', ]
```

Here we put the condition in the row position, before the comma, because we want to subset rows. The blank after the comma indicates we want all the columns returned.

> ## Exercise
> How can we filter the data for just the United Kingdom?

We can answer the question, "Which African countries have population over 10,000,000?" by using the `&` operator with our previous code. This requires both conditions to be true at the same time:

```{r, 'filter_by_continent_population'}
filter(gapminder_1997, continent == 'Africa' & pop >= 10000000)
```

We can subset the data for very large or very small population with the `|` operator, which requires either condition to be true:

```{r, 'filter_by_large_and_small_pop'}
filter(gapminder_1997, pop <= 1000000 | pop >= 1000000000)
```

This gives us all the countries with fewer than a million people **or** more than a billion people.

**Checkpoint**

## Make new columns with `mutate()`

It's common to use existing columns of a data table to create new columns. For example, in the `gapminder_1997` data we have a `pop` column and a `gdpPercap` column. We could multiply these two columns to get a new `gdp` column. The `dplyr` function `mutate()` adds columns to an existing data table.

```{r, 'mutate_gdp'}
mutate(gapminder_1997, gdp = pop * gdpPercap)
```

As before, this didn't actually add the column to `gapminder_1997`, we have to save the object to store it:

```{r, 'mutate_gdp_saved'}
gapminder_gdp_1997 = mutate(gapminder_1997, gdp = pop * gdpPercap)
gapminder_gdp_1997
```

**Checkpoint**

## Combine functions with the `%>%` pipe

We've learned how to subset rows with `filter()`, select columns with `select()`, get distinct elements with `distinct()`, and summarize columns with `summarize()`. It's common to use these functions in sequence, where the output of one becomes the input of the next. The concept of "pipe" (`|`) from `bash` has an equivalent in the `tidyverse` in the `%>%` symbol. To see this in action, let's select data from Oceania and display only the `country`, `continent`, and `pop` columns.

```{r, 'pipe_example1'}
gapminder_1997 %>% filter(continent == 'Oceania') %>% select(country, continent, pop)
```

> ## Question
> 
> Does the order of `filter()` and `select()` matter? Would something like the following work, why or why not?
> 
> ```{r, 'pipe_order', eval = FALSE}
> gapminder_1997 %>% select(country, pop) %>% filter(continent == 'Oceania')
> ```

It seems there are only two countries, Australia and New Zealand. If we wanted to take the mean of the populations we could pipe the data, after filtering, to `summarize()` as in:

```{r, 'pipe_example2'}
gapminder_1997 %>%
    filter(continent == 'Oceania') %>%
    summarize(oceania_mean_pop = mean(pop))
```

Note this is distinct from taking the mean over the entire dataset:

```{r, 'pipe_example3'}
gapminder_1997 %>% summarize(global_mean_pop = mean(pop))
```

Here we've meaningfully named our output, but that was optional. For quick data exploration that could be left off.

**Checkpoint**

## Group rows with `group_by()`

If we wanted to determine the mean populations over all the continents, we could run the above code we used for Oceania, but replace Oceania with each continent name. That's a bit tedious, and the `tidyverse` provides a very nice function, `group_by()`, that breaks a data table up into groups and will perform operations within the groups.

```{r, 'group_by_means'}
gapminder_1997 %>% 
    group_by(continent) %>% 
    summarize(mean_pop = mean(pop))
```

Notice that the Oceania average matches what we got above. Going back to our Oceania subset, we can use `group_by()` with the counting function `n()` to count how many countries there are per continent in the `gapminder_1997` data, and verify that there really only are two:

```{r, 'group_by_count'}
gapminder_1997 %>% 
    group_by(continent) %>% 
    summarize(num_countries_per_continent = n())
```

There is a base R function, `table()`, that tabulates the number of time an entry occurs in a vector, and is useful for quick sanity checking:

```{r, 'count_with_table'}
table(gapminder_1997$continent)
```

**Checkpoint**

> ## Exercise
> 
> The following code generates the following output:
> 
> ```{r, 'dplyr_exercise_example'}
> gapminder_1997 %>% 
>     group_by(continent) %>%
>     summarize(
>         min_pop = min(pop),
>         median_pop = median(pop),
>         max_pop = max(pop)
>     ) %>% 
>     arrange(median_pop)
> ```
> Try to write the code that would generate the following table:
> 
> ```{r, 'dplyr_exercise_hidden', echo = FALSE}
> gapminder_1997 %>% 
>     mutate(gdp = pop * gdpPercap) %>%
>     group_by(continent) %>%
>     summarize(
>         min_gdp = min(gdp),
>         mean_gdp = mean(gdp),
>         median_gdp = median(gdp),
>         max_gdp = max(gdp)
>     ) %>% 
>     arrange(mean_gdp)
> ```

# Exploring data visually

We have learned how to use `dplyr` and `tidyr` functions to subset and summarize data, along with some of the equivalent base R functions. But all of our manipulations have lacked the visual component that can be so helpful in understanding the properties of data. Let's turn our attention to plotting in the `tidyverse` with the `ggplot2` package. The `ggplot2` package is a powerful, easy to use package that creates publication ready plots, and is one of the reasons so many people use R.

## Mappings, aesthetics, and geometries

Let's jump right in and create our first plot using the `ggplot()` function. Along the way we'll discuss the components of a plot, and how `ggplot2` conceptualizes plotting.

```{r, 'plot1'}
ggplot(data = gapminder_1997)
```

When we ran this code the Plots tab popped up and displayed ... a gray rectangle. This is underwhelming as a first plot, but it's a helpful reminder that computers do exactly what we tell them. In this case, we've just told R that we want to plot data from `gapminder_1997`. We haven't told it **how**.

The elements of a plot have properties like: x and y position, size, color, etc. These properties are **aesthetics**, and we need to map variables in our dataset to aesthetics in our plot. This is done with the aesthetic mapping function `aes()`. Let's build up our plot iteratively by mapping `gdpPercap` to the x-axis with:

```{r, 'plot2'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap)
```

In `ggplot2`, the `+` indicates we want to add elements to a plot. It's kind of like the pipe (`%>%`) in `dplyr`. Our plot window is no longer a blank gray square, but now has a labeled x-axis with visual delimiters. Here, `gdpPercap` is just the column name from our data, and isn't really formatted in a "publication-ready" manner. We can use the `labs()` function to alter the label on the x-axis with:

```{r, 'plot3'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita')
```

**Checkpoint**

> ## Exercise
> How would we map life expectancy to the y-axis and give it a nicer label?

```{r, 'plot4'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy')
```

This is progress, but we still don't have any data plotted. For this, we tell the plot object what to draw by adding a "geometry" ("geom" for short). There are many geometries, but we'll begin with `geom_point()`, which plots points in the x-y plane.

```{r, 'plot5'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point()
```

From the plot, it appears that higher GDP correlates with longer life expectancy. We can add a title to the plot with `labs()` to suggest this is the point of the plot:

```{r, 'plot6'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?')
```

**Checkpoint**

## Color

We've made excellent progress on our first plot, and without even having to write very much code! There is much more we can do visually to understand what the data might be telling us in addition to the general trend we've already observed. For example, we can use different colors for each continent to understand how continent affects this relationship:

```{r, 'plot_color_continent'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent)
```

With the continents shown by color, we immediately pick out that African countries tend to have lower life expectancy than other countries. Of course, there are African countries (red points) with life expectancies similar to wealthier countries, suggesting that GDP per capita does not tell the full story about health, as we might have already guessed.

**Checkpoint**

## Scale

When we added the color mapping, ggplot added a legend automatically, assigning different colors to each of the unique values of `continent`. The colors ggplot uses are considered a "scale," and each aesthetic value we can give (x, y, color, etc) has a corresponding scale. Let's experiment with scales briefly to see how that works.

```{r, 'plot_x_log_scale'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_x_log10()
```

Here we see that the x-axis has been scaled by the log10. Depending on the data we're plotting the log scale might be more appropriate than the default linear scale. We can also change the scale on the `continent` mapping to change the colors:

```{r, 'plot_color_continent_set1'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1')
```

The `scale_color_brewer()` function is one of many that changes the colors. There are also many "palettes" built in that are appropriate in different use cases. Run `RColorBrewer::display.brewer.all()` to see them. Note that there are linear color scales which might be appropriate for categorical data denoting intensity levels. There are also divergent color scales that might be useful for continuous variables centered around 0. There are also discrete color scales more appropriate for categorical data that aren't associated with magnitude, like `continent`.

**Checkpoint**

## Size

We also have the population data for each country and we might wonder if population has an effect on life expectancy and GDP per capita. We can map `pop` to the size of the points in the plot by adding another `aes()`. If there was a relationship, we might expect to see larger points concentrated in certain regions of the resulting graph.

> ## Exercise
> 
> Given our previous code mapping data columns to the axes and to color, what would we add to the previous plot code to map the population to the size aesthatic?

```{r, 'plot_pop_size'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1') +
    aes(size = pop)
```

Here ggplot has created another legend for us called `pop`, the name of the column, and it shows the size related to the population. However, this is in scientific notation, which is a little difficult to interpret at a glance. We can change this by dividing all the population values by 1,000,000. We can also change the labels of the legend using the `labs()` function, just as we did for the x and y axes and title.

```{r, 'plot_per_million'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1') +
    labs(color = 'Continent') +
    aes(size = pop/1000000) + 
    labs(size = 'Population (in millions)')
```

From this plot, it doesn't look like population has much to do with either life expectancy or GDP per capita. Notice in the `aes()` with `size` we divided the `pop` column by 1,000,000. This works because columns in aesthetic mappings can be treated just like any other variable, and we can use functions to transform or change them at plot time rather than transforming the data first. We will see later that for more complex transformations, it can be advantageous to transform the data first and build a plot based on the transformed data rather than doing it at plot time.

**Checkpoint**

## Compact code

In this lesson we have built our plot up line by line and accumulated many lines of code. Many of these steps can be combined to make the code a bit more compact and readable:

```{r, 'plot_compact_code'}
ggplot(data = gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?')
```

**Checkpoint**

## Captions

Captions can also be included in the plot itself, if desired, within the `labs()` function:

```{r, 'plot_caption'}
ggplot(data = gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?',
         caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

## Exploring more complex data

The `gapminder_1997` has been useful for exploring `dplyr` and `ggplot` functions. Let's load in a more complex dataset so we have a bit more data to explore. The `data/gapmainder_data.csv` dataset is similar to `gapminder_1997`, but is longitudinal. The first step is to load in the data.

```{r, 'load_gapminder_display', eval = FALSE}
gapminder_data = read_csv('data/gapminder_data.csv')
```

```{r, 'load_gapminder', echo = FALSE}
gapminder_data = read_csv('../data/gapminder_data.csv')
```

Let's look at a preview of the data and explore some functions to see its attributes. First, we can preview it by evaluating a line of code which just names the object:

```{r, 'preview_gapminder'}
gapminder_data
```

**Checkpoint**

Again, the `tibble` provides a nice preview of the data along with many of the attributes including the dimensions and types of columns. There are some functions we can use to determine these attributes on their own:

```{r, 'dim'}
dim(gapminder_data)
```

This gives us the number of rows and columns, respectively.

```{r, 'head'}
head(gapminder_data)
tail(gapminder_data)
```

The `head()` and `tail()` functions display the first and last few rows of an object, respectively. There is also a useful function called "structure", `str()`, which displays the structure of an object. This is especially useful when we don't know what an object contains.

```{r, 'str'}
str(gapminder_data)
```

This is similar to information we see in the `tibble` preview. We see the type of object, dimensions, columns, their type, and a preview of their values. Of course, the `summary()` function works just the same as it did for `gapminder_1997`, and it's a good idea to take a peek and see what the range of the data are:

**Checkpoint**

```{r, 'gapminder_summary'}
summary(gapminder_data)
```

We see the same columns as `gapminder_1997` but we notice that there are many more years of data collected than just 1997. Let's jump right in with a plot to understand what this data looks like. And let's begin with something similar to the scatterplot we did for `gapminder_1997`, but include the year.

```{r, 'full_plot_point'}
ggplot(data = gapminder_data) +
    aes(x = year, y = lifeExp, color = continent) + 
    geom_point()
```

There seems to be an overall trend of higher life expectancy over time, but it's not as clear as it could be. In our plot, the country-level data is not connected, making it hard to understand country-level trends. Before we figure out how to connect the dots, let's use our `dplyr` knowledge to see if that overall trend we suspect is correct.

```{r, 'summarize_lifeexp_over_years'}
gapminder_data %>% group_by(year) %>% summarize(mean_life_exp = mean(lifeExp))
```

That seems clear enough. Of course, this is for all countries combined. We could add continent as an additional group:

```{r, 'summarize_lifeexp_over_years_continents'}
gapminder_data %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp))
```

> ## Exercise
> 
> The above code is ordered by year, but to see the continent-wise trend, it would be easier to see the data arranged by continent, how would we rearrange the rows by continent?

```{r, 'summarize_lifeexp_over_years_continents2'}
gapminder_data %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp)) %>% arrange(continent)
```

This is a step in the right direction, but now the `tibble` preview is actually preventing us from seeing all the data. There are two ways we can see the full result:

```{r, 'view'}
life_exp_by_year_continent = gapminder_data %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp)) %>% arrange(continent)
View(life_exp_by_year_continent)
```

The `View()` function will show the table in the Scripts pane. Another way to accomplish this is to `%>%` pipe `life_exp_by_year_continent` as a `data.frame`:

```{r, 'data.frame'}
life_exp_by_year_continent %>% data.frame
```

<!-- Might also consider the pivot functions here... -->

And the result is printed out in the Console pane. Either way, the trend of increasing life expectancy over time that we saw globally appears to hold across all continents as well. 

**Checkpoint**

## Line geometry

Of course, **seeing** this data would be more compelling, and we already went through the trouble to save the summarized data as its own object, so let's use it to introduce the line geometry `geom_line()`.

```{r, 'plot_lifeexp_line'}
ggplot(life_exp_by_year_continent) + 
    aes(x = year, y = mean_life_exp, color = continent) + 
    geom_line()
```

The `geom_line()` geometry connects the data points across time in the appropriate way. Sure enough, we see what we noticed from looking at the summarized table. This is a good example of needing to summarize the data before plotting, rather than altering the data at runtime, as we did when we divided the population by 1,000,000.

Let's pull this plot back a bit and try to plot all the countries at the same time, rather than an average. Let's try altering the code above and replace `geom_point()` with `geom_line()`:

```{r, 'full_plot_line_wrong'}
ggplot(data = gapminder_data) +
    aes(x = year, y = lifeExp, color = continent) + 
    geom_line()
```

This is definitely not the right thing. We got a line for each continent, but we want a line for each country. To tell `ggplot` to connect the values for each `country`, we use the `group` aesthetic:

```{r, 'full_plot_line_correct'}
ggplot(data = gapminder_data) +
    aes(x = year, y = lifeExp, color = continent, group = country) + 
    geom_line()
```

And now we see each country plotted as its own line so we can see the overall trend, as well as the deviations from the trend.

**Checkpoint**

## Geometries for categories

The `geom_point` and `geom_line` geometries are designed to display numeric values on the x and y axes. Often data has discrete variables (`continent` or `country`) where something like a box plot is more appropriate. Let's revisit our `gapminder_1997` data to create a box plot with the continent on the x axis and the life expectancy on the y-axis.

```{r, 'plot_box'}
ggplot(data = gapminder_1997) + aes(x = continent, y = lifeExp) + geom_boxplot()
```

This makes comparing the range and spread of values across groups easier. The median of the data is displayed, as is the 25% and 75%-iles and any outliers. Another discrete geometry is the `geom_violin`, which gives an indication of the density of the data points along the values being plotted.

```{r, 'plot_violin'}
ggplot(data = gapminder_1997) + aes(x = continent, y = lifeExp) + geom_violin()
```

**Checkpoint**

## Factors

In the above box plots it's perfectly acceptable to have the continents listed in alphabetical order, which is the default when plotting categorical data in `ggplot2`. Imagine, however, that we want a box plot with months on the x-axis and some data on the y-axis. It wouldn't be appropriate to plot the months in alphabetical order. Fortunately there is a data type in R called a **factor** which stores categorical data and enables us to specify the order of the "levels" or categories.

We know that our data has a `continent` column, and we saw before that there were only 5 unique values in this column. This is a perfect candidate to introduce the idea of a factor. Let's `mutate()` the `gapminder_1997` data and add a factor version of the continent column. 

First, let's look at `?factor`. It takes a character vector (exactly what the `continent` column is), and an optional `levels` character vector which dictates the categories and their desired order.

```{r, 'factor1'}
gapminder_factor = gapminder_1997 %>% 
    mutate(continent_factor = factor(continent, levels = c('Oceania', 'Africa', 'Asia', 'America', 'Europe')))
```

Let's take a look at the new object and see how it's different.

```{r, 'factor_preview'}
gapminder_factor
```

Note that the new column has type `fct` (factor) and the old has `chr` (character). That's a good start. Let's look at the head of both columns.

```{r, 'head_continent'}
head(gapminder_factor$continent)
head(gapminder_factor$continent_factor)
```

**Checkpoint**

Notice that for the factor column we get the same output, but with additional information about the `levels`, and the ordering is exactly what we specified. Now let's see the effect on a plot similar to the boxplot we already created above.

```{r, 'factor_boxplot'}
ggplot(data = gapminder_factor) + aes(x = continent_factor, y = lifeExp) + geom_boxplot()
```

Compare this to the plot we saw with the `continent` column, where the order was alphabetical. In the RNA-seq Demystified Workshop we will also see how factors and the order of their levels affect the tests for differential expression.

**Checkpoint**

## Layers

To get a sense for how the data are distributed in the box plot, we could add a layer with `geom_point()` in addition to `geom_boxplot()`.

```{r, 'plot_box_layer'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_point()
```

The points are stacking on top of one another, and it can be hard to tell, for a value of `lifeExp`, if more than one data point is there. We can fix this by "jittering" the points, with `geom_jitter()`.

```{r, 'plot_box_jitter'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter()
```

Within a column, the horizontal position doesn't have meaning, and is meant to visually separate points of the same value. However, it feels like the jitter is a bit wide, causing the boundaries between the continents to be unclear. If we look at the help `?geom_jitter` we'd see a `width` parameter, which controls how wide to allow the jitter.

```{r, 'plot_box_jitter_width'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter(width = 0.15)
```

It may take some iterations of the `width` parameter to get things where we want them. This is pretty common in `ggplot2`. Note that the word "layer" also means that the layers appear in a particular order, for example, if we swap the `geom_boxplot()` and `geom_jitter()` we see that the points are obscured.

```{r, 'plot_box_jitter_layer'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_jitter(width = 0.15) +
    geom_boxplot()
```

Using the `width` parameter in `geom_jitter()`, we saw that it was possible to change aspects of a layer without altering other layers. This carries into the aesthetics too. For example, if we wanted to add a `size` aesthetic using the `pop` to only the `geom_jitter()` layer:

```{r, 'plot_box_jitter_aes'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter(aes(size = pop), width = 0.3)
```

**Checkpoint**

## Color and Fill

Let's have a look at our jittered boxplot and explore `color` and `fill`. When a color is assigned directly, we use the name of the color in quotes, as in 'pink', and we don't need to use the `aes()` function.

```{r, 'plot_box_color1'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink') + 
    geom_jitter(aes(size = pop), width = 0.3)
```

We could add a different color to the points in the `geom_jitter()`, and we would do it outside of the `aes()` if we wanted them to be the same.

```{r, 'plot_box_color2'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink') + 
    geom_jitter(aes(size = pop), color = 'blue', width = 0.3)
```

Notice that `color` changed the outline of the `geom_boxplot()`. We would use `fill` if we wanted to change the inside color of the box plot.

```{r, 'plot_box_color3'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink', fill = 'green') + 
    geom_jitter(aes(size = pop), color = 'blue', width = 0.3)
```

We probably won't publish this particular plot, as beautiful as it is.

We have already seen in other plots that we can link `color` to an attribute of our data. We can do the same with `fill`, but we do it inside of the `aes()` function.

```{r, 'plot_box_color4'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(aes(fill = continent)) + 
    geom_jitter(aes(size = pop), width = 0.3)
```

**Checkpoint**

## Single-variable plots

Our very first plot involved two variables, but it's often helpful to plot a single variable's values as a histogram to understand its distribution. Here the geometries `geom_histogram()` and `geom_density()` can help us. Let's take a look at the histogram for `lifeExp`.

```{r, 'plot_histogram'}
ggplot(data = gapminder_1997) +
    aes(x = lifeExp) + 
    geom_histogram()
```

Here there is a message displayed that the default number of bins is 30 from `geom_histogram()`, but that may not be appropriate for all data. There are two ways we can change the bins the geometry uses to count, `bins` which fixes the number of bins, and `binwidth` which fixes the intervals in which values are counted. Let's change the number of bins to 20.

```{r, 'plot_histogram_bins'}
ggplot(data = gapminder_1997) +
    aes(x = lifeExp) + 
    geom_histogram(bins = 20)
```

We can see there are fewer bins in this plot. If we wanted to make the bins span 5 years, we would do:

```{r, 'plot_histogram_binwidth'}
ggplot(data = gapminder_1997) +
    aes(x = lifeExp) + 
    geom_histogram(binwidth = 5)
```

Changing the binwidth makes the histogram more easily intepretable because we know the range of each bar. If, instead of frequency, we wanted to look at the density, the smoothed version of the histogram, we could use the `geom_density()` geometry.

```{r, 'plot_density'}
ggplot(data = gapminder_1997) +
    aes(x = lifeExp) + 
    geom_density()
```

**Checkpoint**

## Facets

We have used the aesthetics `aes()` to map data to `color`, `fill`, etc. and distinguish differences between the subgroups. Faceting is another technique to plot subgroups in their own panels of a single plot, also helping to distinguish differences between subgroups. We started off a relatively simple plot of GDP per capita versus life expectancy, and later colored it by continent. But let's use facets to split the continents into their own sub-plots.

```{r, 'plot_scatter_facetwrap'}
ggplot(gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp) + 
    geom_point() + 
    facet_wrap(vars(continent))
```

Importantly, we had to use the helper function `vars()` to tell `facet_wrap()` what the column name to use in the facet. The details about why `vars()` is needed are somewhat nuanced, so we won't get into them, but know that some `ggplot2` and `dplyr` functions may require the use of `vars()` when giving column names, whereas in the `aes()` function we don't need the `vars()`.

It might be easier to compare differences in the sub-plots if they were arranged by row or by column, rather than wrapping them in a grid. Have a look at the help for `?facet_grid()`. There are `rows` and `cols` arguments that will display the facets as rows or columns.

```{r, 'plot_scatter_facetgrid'}
ggplot(gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp) + 
    geom_point() + 
    facet_grid(rows = vars(continent))
```

Now there is only one x-axis, and multiple y-axes. Here the scale is the same for all the y-axes to make them comparable, but there are parameters of `facet_grid()` that allow the scales to change depending on the data within the facet itself if that's more appropriate.

**Checkpoint**

# Saving plots

While it's great to keep the code that created the plot in an R script, it's also great to save it as an image so you can share it with people that don't use R, or don't want to run all your code to generate the plot. Since we're saving all our steps in a script, we'll make use of the `ggsave()` function. Let's start by taking a look at the help:

~~~
?ggsave
~~~

Note that it defaults to saving the last displayed plot. also note that there are parameters for the dimensions, the units of the dimensions, and the resolution. Let's run a very basic version of `ggsave()`.

```{r, 'ggsave1', eval = FALSE}
ggsave('first_saved_plot.png', height = 6, width = 6, dpi = 300)
```

**Checkpoint**

We can then navigate to the plot and click to open it in the File pane. Note that R Studio Server let's you easily download any file by clicking any number of checkboxes for the files and then clicking "More" and "Export". In the previous command we've used the `.png` extension, so that `ggsave()` knows to create a PNG, but we could have also used `.jpeg`, `.pdf`, `.eps`, etc to create an appropriate file output. See the documentation for `ggsave()` for supported file formats, and note that this is an easy way to save multiple formats and resolutions depending on whether you want to quickly share with a collaborator, or share with a journal for publication.

We just learned how to save plots as files, but we can also save plots as objects in R. This is helpful for when we want to revisit a plot or make changes to it without having to re-type a bunch of code.

```{r, 'plot_object'}
scatter_plot = ggplot(data = gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?',
         caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

Notice nothing happens as when we ran the code without saving it as an object. If we want to see the plot again, we have to execute the name of the object:

```{r, 'display_plot_object'}
scatter_plot
```

**Checkpoint**

# Customizing plots

Now that we have a nice plot saved as an object, it's a good time to explore different customizations we can add to the plot. Let's start with changing the theme.

```{r, 'change_theme'}
scatter_plot + theme_bw()
```

What did this do? It changed the background color, added a border around the plot area, and perhaps some other things that are too subtle to notice. There are many themes available as presets ([see this link](https://ggplot2.tidyverse.org/reference/ggtheme.html)), but we can also more finely control aspects of our plot with the `theme()` function ([see documentation here](https://ggplot2.tidyverse.org/reference/theme.html) or do `?theme`).

## Change font attributes

We can use the `text` argument of `theme()` to change the size of all the fonts in the plot.

```{r, 'change_font_size'}
scatter_plot + theme(text = element_text(size = 16))
```

We could also rotate the axis labels using either the `axis.text.x` or `axis.text.y` parameter of `theme()`, and then the `angle`, `vjust`, and `hjust` parameters of `element_text()`.

```{r, 'rotate_labels'}
scatter_plot + theme(axis.text.x = element_text(angle = 90))
```

Here the axis labels aren't centered on the ticks, and seem to be center justified. We use the `vjust` and `hjust` parameters to fix that. This is a case where an example from searching the internet was helpful.

```{r, 'rotate_labels2'}
scatter_plot + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

**Checkpoint**

## Labeling points

In the scatterplot, we might want to highlight certain countries, such as Brazil, China, India, and the United States. There is a very nice add-on package called [`ggrepel`](https://ggrepel.slowkow.com/index.html). In particular, if we look at the example for [how to hide some of the labels](https://ggrepel.slowkow.com/articles/examples.html#hide-some-of-the-labels), we'll get a sense for how to write code to highlight these countries.

It seems like we'll need to add a new column to gapminder_1997 that has empty labels (`''`) for the countries other than Brazil, China, India, and the United States.

```{r, 'modify_gapminder'}
library(ggrepel)

gapminder_1997_labels = gapminder_1997 %>% 
    mutate(label = ifelse(country %in% c('Brazil', 'China', 'India', 'United States'), country, ''))
```

What have we done here? We've used the `mutate()` function to create a new column called label, and the criteria for the entries are, if the entry from the `country` column is in the set `c('Brazil', 'China', 'India', 'United Staets')`, then pass on the country name, otherwise give it an empty string `''`. How can we be sure that we've done the right thing?

```{r, 'check_label1'}
gapminder_1997_labels
```

Looks like the labels in the preview are correct, how can we check that the countries we wanted are correct?

```{r, 'check_label2'}
gapminder_1997_labels %>% filter(label != '')
```

So now let's take a cue from the example code and incorporate it into our original code:

```{r, 'plot_labels'}
ggplot(data = gapminder_1997_labels) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000, label = label) + 
    geom_point() + 
    geom_text_repel(box.padding = 0.5, max.overlaps = Inf) +
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?',
         caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

Notice that the size of the label is actually inherited from the size aesthetic. This is an example of aesthetics being inherited by default. This could be changed if we wanted.

**Checkpoint**

We could prevent this inheritance by moving the `color` and `size` aesthetic mappings into `geom_point()` so that they only apply to that layer:

```{r, 'plot_labels2'}
ggplot(data = gapminder_1997_labels) + 
  aes(x = gdpPercap, y = lifeExp, label = label) + 
  geom_point(aes(color = continent, size = pop/1000000)) + 
  geom_text_repel(box.padding = 0.5, max.overlaps = Inf) +
  scale_color_brewer(palette = 'Set1') + 
  labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
       title = 'Do people in wealthier countries live longer?',
       caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```