---
title: "Data Exploration"
output:
        html_document:
            includes:
                in_header: header.html
            theme: paper
            toc: true
            number_sections: false
            fig_caption: false
            markdown: GFM
            code_download: false
---

<style type="text/css">

body, td {
   font-size: 14px;
}
code.r{
  font-size: 12px;
}
pre {
  font-size: 12px
}

</style>

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-")
```

# Objectives

- Subset, filter, and summarize data with `dplyr` functions. Highlight base R equivalents.
- Create plots with both discrete and continuous variables with `ggplot2`.
- Understand mapping and layering in `ggplot2`.
- Modify the color, theme, and axis labels of a plot.

# Loading data

In the previous lesson we used the `read_csv()` function to load the `gapminder_1997` data. Let's do that again:

```{r, 'load_gapminder_1997_display', eval = FALSE}
gapminder_1997 = read_csv('data/gapminder_1997.csv')
```

```{r, 'load_gapminder_1997', echo = FALSE}
gapminder_1997 = read_csv('../data/gapminder_1997.csv')
```

This time, let's look more closely at the data. If we type the name of the object and evaluate it, we'll see a preview:

```{r, 'preview_data'}
gapminder_1997
```

The output shows we have "a tibble" and its dimensions are 142 rows by 6 columns. We then see:

- Column headings (country, year, etc)
- Column data types (chr, dbl, etc)
- The entries of the first 10 rows.

Data in the form of a table is very common in R. The "base R" type is called a `data.frame`. The `tidyverse` extends on this notion with a `tibble`. The commands we'll learn in this lesson work on `data.frame`s and `tibble`s. We'll use `data.frame`, `tibble`, and "data table" interchangeably throughout the lessons.

# Exploring data

After reading in data, it's a good habit to preview it, look at summaries of it, and, in so doing, look for issues. When data contains hundreds of rows, it's a good idea to get a sense for the values and ranges of the data.

## Get stats with `summary()`

The `summary()` function, from base R, takes a data table as input and will summarize the columns automatically depending on their data type.

```{r, 'summary'}
summary(gapminder_1997)
```

We see that for the numeric data we get quantile information and the mean, whereas for character data we simply get the length of the column.

## Get stats with `summarize()`

If we wanted to know the mean life expectancy in the dataset, we could use the built in function `mean()`. If we combine this with the `dplyr` `summarize()` function, we'll get:

```{r, 'summarize_lifeexp'}
summarize(gapminder_1997, avgLifeExp = mean(lifeExp))
```

We can use any column name, so long as it's a numeric, and we get a new object with our value returned as a column. Note, this matches the result of `summary()`. Alternatively, we could have simply applied `mean()` directly to the column `lifeExp`:

```{r, 'mean_lifexp_dollar'}
mean(gapminder_1997$lifeExp)
```

This is a more "base R" way of doing it. Notice we just get a number back, whereas with `summarize()` we got a `tibble`. Here, the `$` is a way to access columns of a data table by name. Another way to express the above is with square-bracket notation:

```{r, 'mean_lifexp_bracket'}
mean(gapminder_1997[, 'lifeExp'])
```

A data table has two dimensions (rows and columns), and, with square-bracket accessors, the rows are in the first position and the columns are in the second position in the brackets separated by a comma. In the above, leaving the row position blank implies "all rows", and in the column position we specify the name of the column. Finally, there is the `with()` approach from base R which looks a bit more like our original call to `summarize()`:

```{r, 'mean_lifeexp_with'}
with(gapminder_1997, mean(lifeExp))
```

In this formulation, we can refer to the column without quotes, like in `summarize()` and other `tidyverse` functions in general.

> ## Tip: Reference columns by name
> 
> While it is possible to access columns by their numerical index, this is less prefereable than using the explicit name of the column because altering the table could change the column indices. Depending on the situation, you might not even get an error, and instead would be simply operating on the wrong column. A dangerous situation to be in.

## Find unique values with `distinct()`

To quickly data entry problems, the `distinct()` function can be used to show all unique values in the column of a table. Let's take a look at the distinct values of the continents column:

```{r, 'distinct_continent'}
distinct(gapminder_1997, continent)
```

Here we get a `tibble` back with the unique continent names in their order of appearance. There is an equivalent base R way to do this with the `unique()` function:

```{r, 'unique_continent'}
unique(gapminder_1997$continent)
```

Either way, if there was a misspelled entry, for example, "Urope" we would have immediately seen it.

## Subset columns with `select()`

Sometimes data tables have many columns, and it can be useful to select only a few of them for exporting, use downstream, previewing, etc. The `select()` function enables us to select a subset of columns:

```{r, 'select_positive'}
select(gapminder_1997, country, year, lifeExp)
```

We can do the equivalent `select()` statement using base R with:

```{r, 'base_select_positive'}
gapminder_1997[ , c('country', 'year', 'lifeExp')]
```

Here, again, we use the square bracket notation, but we have given a vector of column names instead of a single one. Here the `c()` function, meaning "combine", creates a temporary vector of column names.

Columns can be removed using `select()` with a "minus" in front of the column name.

```{r, 'select_negative'}
select(gapminder_1997, -year)
```

Notice the `year` column is no longer displayed. The equivalent can be done in base R with:

```{r, 'base_select_negative'}
gapminder_1997[, -2]
```

Note, the base R syntax works for numerical column indices only. The following throws an error if we try to use the name of the column as we did in the `tidyverse` syntax:

```{r, 'base_select_negative_error', error = TRUE}
gapminder_1997[, -c('year')]
```

Note that if we view `gapminder_1997` we notice haven't changed the original data because we haven't saved the object.

```{r, 'df_persists'}
gapminder_1997
```

To manipulate `gapminder_1997` and save it as a new object we have to assign it a new object name:

```{r, 'new_df'}
gapminder_column_subset = select(gapminder_1997, country, year, lifeExp)
gapminder_column_subset
```

The original data file we read in `data/gapminder_1997.csv` remains the same throughout all these manipulations. What happens in R stays in R until we explicitly write a new object to the same file. **It's good practice to keep raw input data separate, and to never overwrite it.**

## Narrow down rows with `filter()`

We have seen that `select()` subsets the columns of a table. The function `filter()` subsets the rows of a data table based on logical criteria. So first, a note about logical operators in R:

| Operator | Description              | Example      |
|----------|--------------------------|--------------|
| <        | less than                | `pop < 575990` |
| <=       | less than or equal to    | `pop <= 575990` |
| >        | greater than             | `pop > 1000000` |
| >=       | greater than or equal to | `pop >= 38000000` |
| ==       | exactly equal to         | `continent == 'Africa'` |
| !=       | not equal to             | `continent != 'Asia'` |
| !x       | not x                    | `!(continent == 'Africa')` |
| a \| b   | a or b                   | `pop < 575990 | pop > 1000000` |
| a & b    | a and b                  | `continent == 'Asia' & continent == 'Africa'` |
| a %in% b | a in b                   | `continent %in% c('Asia', 'Africa')` |

With these operators in mind we can filter the `gapminder_1997` data table in a variety of ways. To filter for only the African data we could:

```{r, 'filter_by_continent'}
filter(gapminder_1997, continent == 'Africa')
```

The base R equivalent of the above uses the square bracket notation that we saw earlier with a twist:

```{r, 'base_filter_by_continent'}
gapminder_1997[gapminder_1997$continent == 'Africa', ]
```

Here we put the condition in the row position, before the comma, because because we want to subset rows. The blank after the comma indicates we want all the columns returned. An alternative base R way to do this is:

```{r, 'base_subset_filter_by_continent'}
subset(gapminder_1997, continent == 'Africa')
```

This is quite similar to the `tidyverse` syntax, except we're using the `subset()` function from base R instead of `filter()` from `dplyr`.

We can filter the data for African countries above a certain population by using the `&` operator. Essentially requiring multiple things to be true at the same time:

```{r, 'filter_by_continent_population'}
filter(gapminder_1997, continent == 'Africa' & pop >= 10000000)
```

## Make new columns with `mutate()`

It's common to use existing columns of a data table to create new columns. For example, in the `gapminder_1997` data we have a `pop` column and a `gdpPercap` column. We could multiply these two columns to get a new `gdp` column. The `dplyr` function `mutate()` adds columns to an existing data table.

```{r, 'mutate_gdp'}
mutate(gapminder_1997, gdp = pop * gdpPercap)
```

As before, this didn't actually add the column to `gapminder_1997`, we have to save the object to store it:

```{r, 'mutate_gdp_saved'}
gapminder_gdp_1997 = mutate(gapminder_1997, gdp = pop * gdpPercap)
gapminder_gdp_1997
```

## Combine functions with the `%>%` pipe

We've learned how to subset rows with `filter()`, select columns with `select()`, get distinct elements with `distinct()`, and summarize columns with `summarize()`. It's common to use these functions in sequence, where the output of one becomes the input of the next. The "pipe" (`|`) from `bash` has an equivalent in the `tidyverse` in the `%>%` symbol. To see this, let's select data from Oceania and display only the `country`, `continent`, and `pop` columns.

```{r, 'pipe_example1'}
gapminder_1997 %>% filter(continent == 'Oceania') %>% select(country, continent, pop)
```

It seems there are only two countries, Australia and New Zealand. If we wanted to take the mean of the populations we could pipe the above output to `summarize()` as in:

```{r, 'pipe_example2'}
gapminder_1997 %>%
    filter(continent == 'Oceania') %>%
    select(country, continent, pop) %>%
    summarize(oceania_mean_pop = mean(pop))
```

Note this is distinct from taking the mean over the entire data set:

```{r, 'pipe_example3'}
gapminder_1997 %>% summarize(global_mean_pop = mean(pop))
```

Here we've meaningfully named our output, but that was optional. For quick data exploration that could be left off.

## Group rows with `group_by()`

If we wanted to determine the mean populations over all the continents, we could run the above code we used for Oceania, but replace Oceania with each continent name. That's a bit tedious, and the `tidyverse` provides a very nice function, `group_by()`, that breaks a data table up into groups on which to perform operations.

```{r, 'group_by_means'}
gapminder_1997 %>% 
    group_by(continent) %>% 
    summarize(mean_pop = mean(pop))
```

Notice that the Oceania average matches what we got above. Going back to our Oceania subset, we can use `group_by()` with the counting function `n()` to count how many countries there are per continent in the `gapminder_1997` data, and verify that there really only are two:

```{r, 'group_by_count'}
gapminder_1997 %>% 
    group_by(continent) %>% 
    summarize(num_countries_per_continent = n())
```

There is a base R function, `table()`, that tabulates the number of time an entry occurs in a vector, and is useful for quick sanity checking:

```{r, 'count_with_table'}
table(gapminder_1997$continent)
```

# Exploring data visually

We have learned how to use `tidyverse` functions to subset and summarize data, along with some of the equivalent base R functions. But all of our manipulations have lacked the visual component that can be so helpful in understanding the properties of data. Let's now turn our attention to plotting in the `tidyverse` with the `ggplot2` package. The `ggplot2` package is a powerful, easy to use package that creates publication ready plots, and is one of the reasons so many people use R.

Let's jump right in and create our first plot using the `ggplot()` function. And along the way we'll discuss the components of a plot, and how `ggplot2` thinks about plotting.

```{r, 'plot1'}
ggplot(data = gapminder_1997)
```

When we ran this code the Plots tab popped up and displayed ... a gray rectangle. This is underwhelming as a first plot, but it's a helpful reminder that computers do exactly what you tell them. In this case, we've just told R that we want to plot data from the `gapminder_1997` data. We haven't told it **how**.

The elements of a plot have properties like: x and y position, size, color, etc. These properties are **aesthetics**, and we need to map variables in our dataset to aesthetics in our plot. This is done with the aesthetic mapping function `aes()`. Let's build up our plot iteratively by mapping `gdpPercap` to the x-axis with:

```{r, 'plot2'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap)
```

In `ggplot2`, the `+` indicates we want to add elements to a plot. It's kind of like the pipe (`%>%`) in `dplyr`. Our plot window is no longer a blank gray square, but now has a labeled x-axis with visual delimiters. Here, `gdpPercap` is just the column name from our data, and isn't really formatted in a "publication" ready manner. We can use the `labs()` function to alter the label on the x-axis with:

```{r, 'plot3'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita')
```

Now let's map life expectancy to the y-axis, and add a nice label for it:

```{r, 'plot4'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy')
```

This is progress, but we still don't have any data plotted. For this, we tell the plot object what to draw by adding a "geometry" ("geom" for short). There are many geometries, but we'll begin with `geom_point()`, which plots points in the x-y plane.

```{r, 'plot5'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point()
```

