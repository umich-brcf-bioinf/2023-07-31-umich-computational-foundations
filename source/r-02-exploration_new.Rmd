---
title: "Data Exploration"
output:
        html_document:
            includes:
                in_header: header.html
            theme: paper
            toc: true
            number_sections: false
            fig_caption: false
            markdown: GFM
            code_download: false
---

<style type="text/css">

body, td {
   font-size: 14px;
}
code.r{
  font-size: 12px;
}
pre {
  font-size: 12px
}

</style>

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-")
```

# Objectives

- Subset, filter, mutate, group and summarize data with `dplyr` functions. Highlight base R equivalents.
- Understand how to string together multiple functions with the `%>%` pipe.
- Create plots with both discrete and continuous variables with `ggplot2`.
- Understand mappings, geometries, and layering in `ggplot2`.
- Modify the color, theme, and axis labels of a plot.

# Loading data

In the previous lesson we used the `read_csv()` function to load the `gapminder_1997` data. Let's do that again:

```{r, 'load_gapminder_1997_display', eval = FALSE}
gapminder_1997 = read_csv('data/gapminder_1997.csv')
```

```{r, 'load_gapminder_1997', echo = FALSE}
gapminder_1997 = read_csv('../data/gapminder_1997.csv')
```

This time, let's look more closely at the data. If we type the name of the object and evaluate it, we'll see a preview:

```{r, 'preview_data'}
gapminder_1997
```

The output shows we have "a tibble" and its dimensions are 142 rows by 6 columns. We then see:

- Column headings (country, year, etc)
- Column data types (chr, dbl, etc)
- The entries of the first 10 rows.

Data in the form of a table is very common in R. The "base R" type is called a `data.frame`. The `tidyverse` extends on this notion with a `tibble`. The commands we'll learn in this lesson work on `data.frame`s and `tibble`s. We'll use `data.frame`, `tibble`, and "data table" interchangeably throughout the lessons.

# Exploring data

After reading in data, it's a good habit to preview it, look at summaries of it, and, in so doing, look for issues. When data contains hundreds of rows, it's a good idea to get a sense for the values and ranges of the data.

## Get stats with `summary()`

The `summary()` function, from base R, takes a data table as input and will summarize the columns automatically depending on their data type.

```{r, 'summary'}
summary(gapminder_1997)
```

We see that for the numeric data we get quantile information and the mean, whereas for character data we simply get the length of the column.

## Get stats with `summarize()`

If we wanted to know the mean life expectancy in the dataset, we could use the built in function `mean()`. If we combine this with the `dplyr` `summarize()` function, we'll get:

```{r, 'summarize_lifeexp'}
summarize(gapminder_1997, avgLifeExp = mean(lifeExp))
```

We can use any column name, so long as it's a numeric, and we get a new object with our value returned as a column. Note, this matches the result of `summary()`. Alternatively, we could have simply applied `mean()` directly to the column `lifeExp`:

```{r, 'mean_lifexp_dollar'}
mean(gapminder_1997$lifeExp)
```

This is a more "base R" way of doing it. Notice we just get a number back, whereas with `summarize()` we got a `tibble`. Here, the `$` is a way to access columns of a data table by name. 

> ## Tip: Reference columns by name
> 
> While it is possible to access columns by their numerical index, this is less prefereable than using the explicit name of the column because altering the table could change the column indices. Depending on the situation, you might not even get an error, and instead would be simply operating on the wrong column. A dangerous situation to be in.

## Find unique values with `distinct()`

To quickly data entry problems, the `distinct()` function can be used to show all unique values in the column of a table. Let's take a look at the distinct values of the continents column:

```{r, 'distinct_continent'}
distinct(gapminder_1997, continent)
```

Here we get a `tibble` back with the unique continent names in their order of appearance. There is an equivalent base R way to do this with the `unique()` function:

```{r, 'unique_continent'}
unique(gapminder_1997$continent)
```

Either way, if there was a misspelled entry, for example, "Urope" we would have immediately seen it.

## Subset columns with `select()`

Sometimes data tables have many columns, and it can be useful to select only a few of them for exporting, use downstream, previewing, etc. The `select()` function enables us to select a subset of columns:

```{r, 'select_positive'}
select(gapminder_1997, country, year, lifeExp)
```

We can do the equivalent `select()` statement using base R with:

```{r, 'base_select_positive'}
gapminder_1997[ , c('country', 'year', 'lifeExp')]
```

A data table has two dimensions (rows and columns), and, with square-bracket accessors, the rows are in the first position and the columns are in the second position in the brackets separated by a comma. In the above, leaving the row position blank implies "all rows", and in the column position we specify the names of the columns as a vector with the `c()` function, meaning "combine", creates a temporary vector of column names.

Columns can be removed using `select()` with a "minus" in front of the column name.

```{r, 'select_negative'}
select(gapminder_1997, -year)
```

Notice the `year` column is no longer displayed. The equivalent can be done in base R with:

```{r, 'base_select_negative'}
gapminder_1997[, -2]
```

Note, the base R syntax works for numerical column indices only. The following throws an error if we try to use the name of the column as we did in the `tidyverse` syntax:

```{r, 'base_select_negative_error', error = TRUE}
gapminder_1997[, -c('year')]
```

Note that if we view `gapminder_1997` we notice haven't changed the original data because we haven't saved the object.

```{r, 'df_persists'}
gapminder_1997
```

To manipulate `gapminder_1997` and save it as a new object we have to assign it a new object name:

```{r, 'new_df'}
gapminder_column_subset = select(gapminder_1997, country, year, lifeExp)
gapminder_column_subset
```

The original data file we read in `data/gapminder_1997.csv` remains the same throughout all these manipulations. What happens in R stays in R until we explicitly write a new object to the same file. **It's good practice to keep raw input data separate, and to never overwrite it.**

## Narrow down rows with `filter()`

We have seen that `select()` subsets the columns of a table. The function `filter()` subsets the rows of a data table based on logical criteria. So first, a note about logical operators in R:

| Operator | Description              | Example      |
|----------|--------------------------|--------------|
| <        | less than                | `pop < 575990` |
| <=       | less than or equal to    | `pop <= 575990` |
| >        | greater than             | `pop > 1000000` |
| >=       | greater than or equal to | `pop >= 38000000` |
| ==       | exactly equal to         | `continent == 'Africa'` |
| !=       | not equal to             | `continent != 'Asia'` |
| !x       | not x                    | `!(continent == 'Africa')` |
| a \| b   | a or b                   | `pop < 575990 | pop > 1000000` |
| a & b    | a and b                  | `continent == 'Asia' & continent == 'Africa'` |
| a %in% b | a in b                   | `continent %in% c('Asia', 'Africa')` |

With these operators in mind we can filter the `gapminder_1997` data table in a variety of ways. To filter for only the African data we could:

```{r, 'filter_by_continent'}
filter(gapminder_1997, continent == 'Africa')
```

The base R equivalent of the above uses the square bracket notation that we saw earlier with a twist:

```{r, 'base_filter_by_continent'}
gapminder_1997[gapminder_1997$continent == 'Africa', ]
```

Here we put the condition in the row position, before the comma, because because we want to subset rows. The blank after the comma indicates we want all the columns returned. An alternative base R way to do this is:

```{r, 'base_subset_filter_by_continent'}
subset(gapminder_1997, continent == 'Africa')
```

This is quite similar to the `tidyverse` syntax, except we're using the `subset()` function from base R instead of `filter()` from `dplyr`.

We can filter the data for African countries above a certain population by using the `&` operator. Essentially requiring multiple things to be true at the same time:

```{r, 'filter_by_continent_population'}
filter(gapminder_1997, continent == 'Africa' & pop >= 10000000)
```

## Make new columns with `mutate()`

It's common to use existing columns of a data table to create new columns. For example, in the `gapminder_1997` data we have a `pop` column and a `gdpPercap` column. We could multiply these two columns to get a new `gdp` column. The `dplyr` function `mutate()` adds columns to an existing data table.

```{r, 'mutate_gdp'}
mutate(gapminder_1997, gdp = pop * gdpPercap)
```

As before, this didn't actually add the column to `gapminder_1997`, we have to save the object to store it:

```{r, 'mutate_gdp_saved'}
gapminder_gdp_1997 = mutate(gapminder_1997, gdp = pop * gdpPercap)
gapminder_gdp_1997
```

## Combine functions with the `%>%` pipe

We've learned how to subset rows with `filter()`, select columns with `select()`, get distinct elements with `distinct()`, and summarize columns with `summarize()`. It's common to use these functions in sequence, where the output of one becomes the input of the next. The "pipe" (`|`) from `bash` has an equivalent in the `tidyverse` in the `%>%` symbol. To see this, let's select data from Oceania and display only the `country`, `continent`, and `pop` columns.

```{r, 'pipe_example1'}
gapminder_1997 %>% filter(continent == 'Oceania') %>% select(country, continent, pop)
```

It seems there are only two countries, Australia and New Zealand. If we wanted to take the mean of the populations we could pipe the above output to `summarize()` as in:

```{r, 'pipe_example2'}
gapminder_1997 %>%
    filter(continent == 'Oceania') %>%
    select(country, continent, pop) %>%
    summarize(oceania_mean_pop = mean(pop))
```

Note this is distinct from taking the mean over the entire data set:

```{r, 'pipe_example3'}
gapminder_1997 %>% summarize(global_mean_pop = mean(pop))
```

Here we've meaningfully named our output, but that was optional. For quick data exploration that could be left off.

## Group rows with `group_by()`

If we wanted to determine the mean populations over all the continents, we could run the above code we used for Oceania, but replace Oceania with each continent name. That's a bit tedious, and the `tidyverse` provides a very nice function, `group_by()`, that breaks a data table up into groups on which to perform operations.

```{r, 'group_by_means'}
gapminder_1997 %>% 
    group_by(continent) %>% 
    summarize(mean_pop = mean(pop))
```

Notice that the Oceania average matches what we got above. Going back to our Oceania subset, we can use `group_by()` with the counting function `n()` to count how many countries there are per continent in the `gapminder_1997` data, and verify that there really only are two:

```{r, 'group_by_count'}
gapminder_1997 %>% 
    group_by(continent) %>% 
    summarize(num_countries_per_continent = n())
```

There is a base R function, `table()`, that tabulates the number of time an entry occurs in a vector, and is useful for quick sanity checking:

```{r, 'count_with_table'}
table(gapminder_1997$continent)
```

# Exploring data visually

We have learned how to use `dplyr` and `tidyr` functions to subset and summarize data, along with some of the equivalent base R functions. But all of our manipulations have lacked the visual component that can be so helpful in understanding the properties of data. Let's turn our attention to plotting in the `tidyverse` with the `ggplot2` package. The `ggplot2` package is a powerful, easy to use package that creates publication ready plots, and is one of the reasons so many people use R.

## Mappings, aesthetics, and geometries

Let's jump right in and create our first plot using the `ggplot()` function. Along the way we'll discuss the components of a plot, and how `ggplot2` conceptualizes plotting.

```{r, 'plot1'}
ggplot(data = gapminder_1997)
```

When we ran this code the Plots tab popped up and displayed ... a gray rectangle. This is underwhelming as a first plot, but it's a helpful reminder that computers do exactly what you tell them. In this case, we've just told R that we want to plot data from `gapminder_1997`. We haven't told it **how**.

The elements of a plot have properties like: x and y position, size, color, etc. These properties are **aesthetics**, and we need to map variables in our dataset to aesthetics in our plot. This is done with the aesthetic mapping function `aes()`. Let's build up our plot iteratively by mapping `gdpPercap` to the x-axis with:

```{r, 'plot2'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap)
```

In `ggplot2`, the `+` indicates we want to add elements to a plot. It's kind of like the pipe (`%>%`) in `dplyr`. Our plot window is no longer a blank gray square, but now has a labeled x-axis with visual delimiters. Here, `gdpPercap` is just the column name from our data, and isn't really formatted in a "publication" ready manner. We can use the `labs()` function to alter the label on the x-axis with:

```{r, 'plot3'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita')
```

Now let's map life expectancy to the y-axis, and add a nice label for it:

```{r, 'plot4'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy')
```

This is progress, but we still don't have any data plotted. For this, we tell the plot object what to draw by adding a "geometry" ("geom" for short). There are many geometries, but we'll begin with `geom_point()`, which plots points in the x-y plane.

```{r, 'plot5'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point()
```

From the plot, it appears that higher GDP correlates with longer life expectancy. We can add a title to the plot with `labs()` to suggest this is the point of the plot:

```{r, 'plot6'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?')
```

## Color

We've made excellent progress on our first plot, and without even having to write very much code! There is much more we can do visually to understand what the data might be telling us in addition to the general trend we've already observed. For example, we can use different colors for each continent to understand how continent affects this relationship:

```{r, 'plot_color_continent'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent)
```

With the continents shown by color, we immediately pick out that African countries tend to have lower life expectancy than other countries. Of course, there are African countries (red points) with life expectancies similar to wealthier countries, suggesting that GDP per capita does not tell the full story about health, as we might have already guessed.

## Scale

When we added the color mapping, ggplot added a legend automatically, assigning different colors to each of the unique values of `continent`. The colors ggplot uses are considered a "scale," and each aesthetic value we can give (x, y, color, etc) has a corresponding scale. Let's experiment with scales briefly to see how that works.

```{r, 'plot_x_log_scale'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_x_log10()
```

Here we see that the x-axis has been scaled by the log10. Depending on the data we're plotting the log scale might be more appropriate than the default linear scale. We can also change the scale on the `continent` mapping to change the colors:

```{r, 'plot_color_continent_set1'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1')
```

The `scale_color_brewer()` function is one of many that changes the colors. There are also many "palettes" built in that are appropriate in different use cases. Run `RColorBrewer::display.brewer.all()` to see them. Note that there are linear color scales which might be appropriate for categorical data denoting intensity levels. There are also divergent color scales that might be useful for continuous variables centered around 0. There are also discrete color scales more appropriate for categorical data that aren't associated with magnitude, like `continent`.

## Size

We also have the population data for each country and we might wonder if population has an effect on life expectancy and GDP per capita. We can map `pop` to the size of the points in the plot by adding another `aes()`:

```{r, 'plot_pop_size'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1') +
    aes(size = pop)
```

Here ggplot has created another legend for us called `pop`, the name of the column, and it shows the size related to the population. However, this is in scientific notation, which is a little difficult to interpret at a glance. We can change this by dividing all the population values by 1,000,000. We can also change the labels of the legend using the `labs()` function, just as we did for the x and y axes and title.

```{r, 'plot_per_million'}
ggplot(data = gapminder_1997) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1') +
    labs(color = 'Continent') +
    aes(size = pop/1000000) + 
    labs(size = 'Population (in millions)')
```

From this plot, it doesn't look like population has much to do with either life expectancy or GDP per capita. Notice in the `aes()` with `size` we divided the `pop` column by 1,000,000. This works because columns in aesthetic mappings can be treated just like any other variable, and we can use functions to transform or change them at plot time rather than transforming the data first. We will see later that for more complex transformations, it can be advantageous to transform the data first and build a plot based on the transformed data rather than doing it at plot time.

## Compact code

We have built our plot up in this lesson, and accumulated many lines of code. Many of these steps can be combined to make the code a bit more compact and readable:

```{r, 'plot_compact_code'}
ggplot(data = gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?')
```

## Captions

Captions can also be included in the plot itself, if desired, within the `labs()` function:

```{r, 'plot_caption'}
ggplot(data = gapminder_1997) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?',
         caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

# Exploring more complex data

The `gapminder_1997` has been useful for exploring `dplyr` and `ggplot` functions. Let's load in a more complex dataset so we have a bit more data to explore. The `data/gapmainder_data.csv` dataset is similar to `gapminder_1997`, but is longitudinal. Let's load it in and explore it:

```{r, 'load_gapminder_display', eval = FALSE}
gapminder_data = read_csv('data/gapminder_data.csv')
```

```{r, 'load_gapminder', echo = FALSE}
gapminder_data = read_csv('../data/gapminder_data.csv')
```

Let's look at a preview of the data and explore some functions to see its attributes. First, we can preview it by evaluating a line of code which just names the object:

```{r, 'preview_gapminder'}
gapminder_data
```

Again, the `tibble` provides a nice preview of the data along with many of the attributes including the dimensions and types of columns. There are some functions we can use to determine these attributes on their own:

```{r, 'dim'}
dim(gapminder_data)
```

This gives us the number of rows and columns, respectively.

```{r, 'head'}
head(gapminder_data)
tail(gapminder_data)
```

The `head()` and `tail()` functions display the first and last few rows of an object, respectively. There is also a useful function called "structure", `str()`, which displays the structure of an object. This is especially useful when we don't know what an object contains.

```{r, 'str'}
str(gapminder_data)
```

This is similar to information we see in the `tibble` preview. We see the type of object, dimensions, columns, their type, and a preview of their values. Of course, the `summary()` function works just the same as it did for `gapminder_1997`, and it's a good idea to take a peek and see what the range of the data are:

```{r, 'gapminder_summary'}
summary(gapminder_data)
```

We see the same columns as `gapminder_1997` but we notice that there are many more years of data collected than just 1997. Let's jump right in with a plot to understand what this data looks like. And let's begin with something similar to the scatterplot we did for `gapminder_1997`, but include the year.

```{r, 'full_plot_point'}
ggplot(data = gapminder_data) +
    aes(x = year, y = lifeExp, color = continent) + 
    geom_point()
```

There seems to be an overall trend of higher life expectancy over time, but it's not as clear as it could be. In our plot, the data connecting countries is not apparent. Before we figure out how to connect the dots, let's use our `dplyr` knowledge to see if that overall trend we suspect is correct.

```{r, 'summarize_lifeexp_over_years'}
gapminder_data %>% group_by(year) %>% summarize(mean_life_exp = mean(lifeExp))
```

That seems clear enough. Of course, this is for all countries combined. We could add an additional group of continent:

```{r, 'summarize_lifeexp_over_years_continents'}
gapminder_data %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp))
```

But this is ordered by year, and to clearly see the trend, ordering by continent would be better:

```{r, 'summarize_lifeexp_over_years_continents2'}
gapminder_data %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp)) %>% arrange(continent)
```

This is a step in the right direction, but now the `tibble` preview is actually preventing us from seeing all the data. There are two ways we can see the full result:

```{r, 'view'}
life_exp_by_year_continent = gapminder_data %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp)) %>% arrange(continent)
View(life_exp_by_year_continent)
```

The `View()` function will show the table in the Scripts pane. Another way to accomplish this is to `%>%` pipe `life_exp_by_year_continent` as a `data.frame`:

```{r, 'data.frame'}
life_exp_by_year_continent %>% data.frame
```

And the result is printed out in the Console pane. Either way, the trend of increasing life expectancy over time that we saw globally appears to hold across all continents as well. 

## Line geometry

Of course, **seeing** this data would be more compelling, and we already went through the trouble to save the summarized data as its own object, so let's use it to introduce the line geometry `geom_line()`.

```{r, 'plot_lifeexp_line'}
ggplot(life_exp_by_year_continent) + 
    aes(x = year, y = mean_life_exp, color = continent) + 
    geom_line()
```

The `geom_line()` geometry connects the data points across time in the appropriate way. Sure enough, we see what we noticed from looking at the summarized table. This is a good example of needing to summarize the data before plotting, rather than altering the data at runtime, as we did when we divided the population by 1,000,000.

Let's pull this plot back a bit and try to plot all the countries at the same time, rather than an average. Let's try altering the code above and replace `geom_point()` with `geom_line()`:

```{r, 'full_plot_line_wrong'}
ggplot(data = gapminder_data) +
    aes(x = year, y = lifeExp, color = continent) + 
    geom_line()
```

This is definitely not the right thing. We got a line for each continent, but we want a line for each country. To tell `ggplot` to connect the values for each `country`, we use the `group` aesthetic:

```{r, 'full_plot_line_correct'}
ggplot(data = gapminder_data) +
    aes(x = year, y = lifeExp, color = continent, group = country) + 
    geom_line()
```

And now we see each country plotted as its own line so we can see the overall trend, as well as the deviations from the trend.

## Geometries for categories

The `geom_point` and `geom_line` geometries are designed to display numeric values on the x and y axes. Often data has discrete variables (`continent` or `country`) where something like a box plot is more appropriate. Let's revisit our `gapminder_1997` data to create a box plot with the continent on the x axis and the life expectancy on the y-axis.

```{r, 'plot_box'}
ggplot(data = gapminder_1997) + aes(x = continent, y = lifeExp) + geom_boxplot()
```

This makes comparing the range and spread of values across groups easier. The median of the data is displayed, as is the 25% and 75%-iles and any outliers. Another discrete geometry is the `geom_violin`, which gives an indication of the density of the data points along the values being plotted.

```{r, 'plot_violin'}
ggplot(data = gapminder_1997) + aes(x = continent, y = lifeExp) + geom_violin()
```

## Layers

To get a sense for how the data are distributed in the box plot, we could add a layer with `geom_point()` in addition to `geom_boxplot()`.

```{r, 'plot_box_layer'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_point()
```

The points are stacking on top of one another, and it can be hard to tell, for a value of `lifeExp`, if more than one data point is there. We can fix this by "jittering" the points, with `geom_jitter()`.

```{r, 'plot_box_jitter'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter()
```

Within a column, the horizontal position doesn't have meaning, and is meant to visually separate points of the same value. However, it feels like the jitter is a bit wide, causing the boundaries between the continents to be unclear. If we look at the help `?geom_jitter` we'd see a `width` parameter, which controls how wide to allow the jitter.

```{r, 'plot_box_jitter_width'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter(width = 0.15)
```

It may take some iterations of the `width` parameter to get things where you want them. This is pretty common in `ggplot2`. Note that the word "layer" also means that the layers appear in a particular order, for example, if we swap the `geom_boxplot()` and `geom_jitter()` we see that the points are obscured.

```{r, 'plot_box_jitter_layer'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_jitter(width = 0.15) +
    geom_boxplot()
```

Using the `width` parameter in `geom_jitter()`, we saw that it was possible to change aspects of a layer without altering other layers. This carries into the aesthetics too. For example, if we wanted to add a `size` aesthetic using the `pop` to only the `geom_jitter()` layer:

```{r, 'plot_box_jitter_aes'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter(aes(size = pop), width = 0.3)
```

## Color and Fill

Let's have a look at our jittered boxplot and explore `color` and `fill`. When a color is assigned directly, we use the name of the color in quotes, as in 'pink', and we don't need to use the `aes()` function.

```{r, 'plot_box_color1'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink') + 
    geom_jitter(aes(size = pop), width = 0.3)
```

We could add a different color to the points in the `geom_jitter()`, and we would do it outside of the `aes()` if we wanted them to be the same.

```{r, 'plot_box_color2'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink') + 
    geom_jitter(aes(size = pop), color = 'blue', width = 0.3)
```

Notice that `color` changed the outline of the `geom_boxplot()`. We would use `fill` if we wanted to change the inside color of the box plot.

```{r, 'plot_box_color3'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink', fill = 'green') + 
    geom_jitter(aes(size = pop), color = 'blue', width = 0.3)
```

We probably won't publish this particular plot, as beautiful as it is.

We have already seen in other plots that we can link `color` to an attribute of our data. We can do the same with `fill`, but we do it inside of the `aes()` function.

```{r, 'plot_box_color4'}
ggplot(data = gapminder_1997) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(aes(fill = continent)) + 
    geom_jitter(aes(size = pop), width = 0.3)
```
